import { createContext, useContext, useRef, useState } from "react"
import * as d3 from "d3"

/**
 * Props to be included in the ZoomContext
*/
interface ZoomContextProps {
    sizing: {
        width: number
        margin: number
    }
    xScale: d3.ScaleLinear<number, number, never>
    zoomTransform: d3.ZoomTransform
    handleZoom: (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => void
}
const ZoomContext = createContext<ZoomContextProps | null>(null)

/**
 * Props required to be passed into the component to maintain consistent look
*/
interface ZoomProviderProps {
    width: number
    margin: number
    domain: [number, number]
    children: React.ReactNode
}

/**
 * Gives children components access to a zoom context, which allows the x-axis pan and zoom to be linked
 */
export const ZoomProvider = ({width, margin, domain, children}: ZoomProviderProps) => {
    // Refrence to the base scaling which should not be altered when zooming
    const xScaleBase = useRef(d3.scaleLinear().domain(domain).range([margin, width-margin]))
    // State representing the zoomed scale which is used by child components to draw
    const [xScale, setXScale] = useState(() => 
        xScaleBase.current.copy()
    )
    // Transform must be tracked to synchronise between linked components
    const [zoomTransform, setZoomTransform] = useState(d3.zoomIdentity)

    /**
     * This callback is used by child components to pass the zoom event back to the provider
     * @param event Zoom event generated by D3
     */
    const handleZoom = (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => {
        setZoomTransform(event.transform)
        setXScale(() => {
            return event.transform.rescaleX(xScaleBase.current)
        })
    }

    return (
        <ZoomContext.Provider value={{xScale, zoomTransform, handleZoom, sizing: {
            width,
            margin
        }}}>
            {children}
        </ZoomContext.Provider>
    )
}

/**
 * Hook to the context provided by ZoomProvider - enforces use inside the correct provider component
 * @returns ZoomContext which can be destructured inside child components
 */
export const useZoom = () => {
    const context = useContext(ZoomContext);
    if (!context) {
        throw new Error("useZoom must be used within a ZoomProvider")
    }
    return context
}